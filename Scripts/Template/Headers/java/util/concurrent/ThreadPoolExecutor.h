//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: android/platform/libcore/luni/src/main/java/java/util/concurrent/ThreadPoolExecutor.java
//

#include "J2ObjC_header.h"

#pragma push_macro("INCLUDE_ALL_JavaUtilConcurrentThreadPoolExecutor")
#ifdef RESTRICT_JavaUtilConcurrentThreadPoolExecutor
#define INCLUDE_ALL_JavaUtilConcurrentThreadPoolExecutor 0
#else
#define INCLUDE_ALL_JavaUtilConcurrentThreadPoolExecutor 1
#endif
#undef RESTRICT_JavaUtilConcurrentThreadPoolExecutor

#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"

#if __has_feature(nullability)
#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wnullability"
#pragma GCC diagnostic ignored "-Wnullability-completeness"
#endif

#if !defined (JavaUtilConcurrentThreadPoolExecutor_) && (INCLUDE_ALL_JavaUtilConcurrentThreadPoolExecutor || defined(INCLUDE_JavaUtilConcurrentThreadPoolExecutor))
#define JavaUtilConcurrentThreadPoolExecutor_

#define RESTRICT_JavaUtilConcurrentAbstractExecutorService 1
#define INCLUDE_JavaUtilConcurrentAbstractExecutorService 1
#include "java/util/concurrent/AbstractExecutorService.h"

@class JavaLangThread;
@class JavaLangThrowable;
@class JavaUtilConcurrentThreadPoolExecutor_Worker;
@class JavaUtilConcurrentTimeUnit;
@protocol JavaLangRunnable;
@protocol JavaUtilConcurrentBlockingQueue;
@protocol JavaUtilConcurrentRejectedExecutionHandler;
@protocol JavaUtilConcurrentThreadFactory;
@protocol JavaUtilList;

@interface JavaUtilConcurrentThreadPoolExecutor : JavaUtilConcurrentAbstractExecutorService

#pragma mark Public

/*!
 @brief Creates a new <code>ThreadPoolExecutor</code> with the given initial
  parameters and default thread factory and rejected execution handler.
 It may be more convenient to use one of the <code>Executors</code> factory
  methods instead of this general purpose constructor.
 @param corePoolSize the number of threads to keep in the pool, even         if they are idle, unless 
 <code>allowCoreThreadTimeOut</code>  is set
 @param maximumPoolSize the maximum number of threads to allow in the         pool
 @param keepAliveTime when the number of threads is greater than         the core, this is the maximum time that excess idle threads
          will wait for new tasks before terminating.
 @param unit the time unit for the <code>keepAliveTime</code>  argument
 @param workQueue the queue to use for holding tasks before they are         executed.  This queue will hold only the 
 <code>Runnable</code>         tasks submitted by the 
 <code>execute</code>  method.
 @throw IllegalArgumentExceptionif one of the following holds:<br>
          <code>corePoolSize < 0</code><br>
          <code>keepAliveTime < 0</code><br>
          <code>maximumPoolSize <= 0</code><br>
          <code>maximumPoolSize < corePoolSize</code>
 @throw NullPointerExceptionif <code>workQueue</code> is null
 */
- (instancetype __nonnull)initWithInt:(jint)corePoolSize
                              withInt:(jint)maximumPoolSize
                             withLong:(jlong)keepAliveTime
       withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit *)unit
  withJavaUtilConcurrentBlockingQueue:(id<JavaUtilConcurrentBlockingQueue>)workQueue;

/*!
 @brief Creates a new <code>ThreadPoolExecutor</code> with the given initial
  parameters and default thread factory.
 @param corePoolSize the number of threads to keep in the pool, even         if they are idle, unless 
 <code>allowCoreThreadTimeOut</code>  is set
 @param maximumPoolSize the maximum number of threads to allow in the         pool
 @param keepAliveTime when the number of threads is greater than         the core, this is the maximum time that excess idle threads
          will wait for new tasks before terminating.
 @param unit the time unit for the <code>keepAliveTime</code>  argument
 @param workQueue the queue to use for holding tasks before they are         executed.  This queue will hold only the 
 <code>Runnable</code>         tasks submitted by the 
 <code>execute</code>  method.
 @param handler the handler to use when execution is blocked         because the thread bounds and queue capacities are reached
 @throw IllegalArgumentExceptionif one of the following holds:<br>
          <code>corePoolSize < 0</code><br>
          <code>keepAliveTime < 0</code><br>
          <code>maximumPoolSize <= 0</code><br>
          <code>maximumPoolSize < corePoolSize</code>
 @throw NullPointerExceptionif <code>workQueue</code>
          or <code>handler</code> is null
 */
- (instancetype __nonnull)initWithInt:(jint)corePoolSize
                              withInt:(jint)maximumPoolSize
                             withLong:(jlong)keepAliveTime
       withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit *)unit
  withJavaUtilConcurrentBlockingQueue:(id<JavaUtilConcurrentBlockingQueue>)workQueue
withJavaUtilConcurrentRejectedExecutionHandler:(id<JavaUtilConcurrentRejectedExecutionHandler>)handler;

/*!
 @brief Creates a new <code>ThreadPoolExecutor</code> with the given initial
  parameters and default rejected execution handler.
 @param corePoolSize the number of threads to keep in the pool, even         if they are idle, unless 
 <code>allowCoreThreadTimeOut</code>  is set
 @param maximumPoolSize the maximum number of threads to allow in the         pool
 @param keepAliveTime when the number of threads is greater than         the core, this is the maximum time that excess idle threads
          will wait for new tasks before terminating.
 @param unit the time unit for the <code>keepAliveTime</code>  argument
 @param workQueue the queue to use for holding tasks before they are         executed.  This queue will hold only the 
 <code>Runnable</code>         tasks submitted by the 
 <code>execute</code>  method.
 @param threadFactory the factory to use when the executor         creates a new thread
 @throw IllegalArgumentExceptionif one of the following holds:<br>
          <code>corePoolSize < 0</code><br>
          <code>keepAliveTime < 0</code><br>
          <code>maximumPoolSize <= 0</code><br>
          <code>maximumPoolSize < corePoolSize</code>
 @throw NullPointerExceptionif <code>workQueue</code>
          or <code>threadFactory</code> is null
 */
- (instancetype __nonnull)initWithInt:(jint)corePoolSize
                              withInt:(jint)maximumPoolSize
                             withLong:(jlong)keepAliveTime
       withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit *)unit
  withJavaUtilConcurrentBlockingQueue:(id<JavaUtilConcurrentBlockingQueue>)workQueue
  withJavaUtilConcurrentThreadFactory:(id<JavaUtilConcurrentThreadFactory>)threadFactory;

/*!
 @brief Creates a new <code>ThreadPoolExecutor</code> with the given initial
  parameters.
 @param corePoolSize the number of threads to keep in the pool, even         if they are idle, unless 
 <code>allowCoreThreadTimeOut</code>  is set
 @param maximumPoolSize the maximum number of threads to allow in the         pool
 @param keepAliveTime when the number of threads is greater than         the core, this is the maximum time that excess idle threads
          will wait for new tasks before terminating.
 @param unit the time unit for the <code>keepAliveTime</code>  argument
 @param workQueue the queue to use for holding tasks before they are         executed.  This queue will hold only the 
 <code>Runnable</code>         tasks submitted by the 
 <code>execute</code>  method.
 @param threadFactory the factory to use when the executor         creates a new thread
 @param handler the handler to use when execution is blocked         because the thread bounds and queue capacities are reached
 @throw IllegalArgumentExceptionif one of the following holds:<br>
          <code>corePoolSize < 0</code><br>
          <code>keepAliveTime < 0</code><br>
          <code>maximumPoolSize <= 0</code><br>
          <code>maximumPoolSize < corePoolSize</code>
 @throw NullPointerExceptionif <code>workQueue</code>
          or <code>threadFactory</code> or <code>handler</code> is null
 */
- (instancetype __nonnull)initWithInt:(jint)corePoolSize
                              withInt:(jint)maximumPoolSize
                             withLong:(jlong)keepAliveTime
       withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit *)unit
  withJavaUtilConcurrentBlockingQueue:(id<JavaUtilConcurrentBlockingQueue>)workQueue
  withJavaUtilConcurrentThreadFactory:(id<JavaUtilConcurrentThreadFactory>)threadFactory
withJavaUtilConcurrentRejectedExecutionHandler:(id<JavaUtilConcurrentRejectedExecutionHandler>)handler;

/*!
 @brief Sets the policy governing whether core threads may time out and
  terminate if no tasks arrive within the keep-alive time, being
  replaced if needed when new tasks arrive.When false, core
  threads are never terminated due to lack of incoming
  tasks.
 When true, the same keep-alive policy applying to
  non-core threads applies also to core threads. To avoid
  continual thread replacement, the keep-alive time must be
  greater than zero when setting <code>true</code>. This method
  should in general be called before the pool is actively used.
 @param value<code>true</code>  if should time out, else <code>false</code>
 @throw IllegalArgumentExceptionif value is <code>true</code>
          and the current keep-alive time is not greater than zero
 @since 1.6
 */
- (void)allowCoreThreadTimeOutWithBoolean:(jboolean)value;

/*!
 @brief Returns true if this pool allows core threads to time out and
  terminate if no tasks arrive within the keepAlive time, being
  replaced if needed when new tasks arrive.When true, the same
  keep-alive policy applying to non-core threads applies also to
  core threads.
 When false (the default), core threads are never
  terminated due to lack of incoming tasks.
 @return <code>true</code> if core threads are allowed to time out,
          else <code>false</code>
 @since 1.6
 */
- (jboolean)allowsCoreThreadTimeOut;

- (jboolean)awaitTerminationWithLong:(jlong)timeout
      withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit *)unit;

/*!
 @brief Executes the given task sometime in the future.The task
  may execute in a new thread or in an existing pooled thread.
 If the task cannot be submitted for execution, either because this
  executor has been shutdown or because its capacity has been reached,
  the task is handled by the current <code>RejectedExecutionHandler</code>.
 @param command the task to execute
 @throw RejectedExecutionExceptionat discretion of
          <code>RejectedExecutionHandler</code>, if the task
          cannot be accepted for execution
 @throw NullPointerExceptionif <code>command</code> is null
 */
- (void)executeWithJavaLangRunnable:(id<JavaLangRunnable>)command;

/*!
 @brief Returns the approximate number of threads that are actively
  executing tasks.
 @return the number of threads
 */
- (jint)getActiveCount;

/*!
 @brief Returns the approximate total number of tasks that have
  completed execution.Because the states of tasks and threads
  may change dynamically during computation, the returned value
  is only an approximation, but one that does not ever decrease
  across successive calls.
 @return the number of tasks
 */
- (jlong)getCompletedTaskCount;

/*!
 @brief Returns the core number of threads.
 @return the core number of threads
 - seealso: #setCorePoolSize
 */
- (jint)getCorePoolSize;

/*!
 @brief Returns the thread keep-alive time, which is the amount of time
  that threads may remain idle before being terminated.
 Threads that wait this amount of time without processing a
  task will be terminated if there are more than the core
  number of threads currently in the pool, or if this pool 
 core thread timeout.
 @param unit the desired time unit of the result
 @return the time limit
 - seealso: #setKeepAliveTime(long, TimeUnit)
 */
- (jlong)getKeepAliveTimeWithJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit *)unit;

/*!
 @brief Returns the largest number of threads that have ever
  simultaneously been in the pool.
 @return the number of threads
 */
- (jint)getLargestPoolSize;

/*!
 @brief Returns the maximum allowed number of threads.
 @return the maximum allowed number of threads
 - seealso: #setMaximumPoolSize
 */
- (jint)getMaximumPoolSize;

/*!
 @brief Returns the current number of threads in the pool.
 @return the number of threads
 */
- (jint)getPoolSize;

/*!
 @brief Returns the task queue used by this executor.Access to the
  task queue is intended primarily for debugging and monitoring.
 This queue may be in active use.  Retrieving the task queue
  does not prevent queued tasks from executing.
 @return the task queue
 */
- (id<JavaUtilConcurrentBlockingQueue>)getQueue;

/*!
 @brief Returns the current handler for unexecutable tasks.
 @return the current handler
 - seealso: #setRejectedExecutionHandler(RejectedExecutionHandler)
 */
- (id<JavaUtilConcurrentRejectedExecutionHandler>)getRejectedExecutionHandler;

/*!
 @brief Returns the approximate total number of tasks that have ever been
  scheduled for execution.Because the states of tasks and
  threads may change dynamically during computation, the returned
  value is only an approximation.
 @return the number of tasks
 */
- (jlong)getTaskCount;

/*!
 @brief Returns the thread factory used to create new threads.
 @return the current thread factory
 - seealso: #setThreadFactory(ThreadFactory)
 */
- (id<JavaUtilConcurrentThreadFactory>)getThreadFactory;

- (jboolean)isShutdown;

- (jboolean)isTerminated;

/*!
 @brief Returns true if this executor is in the process of terminating
  after <code>shutdown</code> or <code>shutdownNow</code> but has not
  completely terminated.This method may be useful for
  debugging.
 A return of <code>true</code> reported a sufficient
  period after shutdown may indicate that submitted tasks have
  ignored or suppressed interruption, causing this executor not
  to properly terminate.
 @return <code>true</code> if terminating but not yet terminated
 */
- (jboolean)isTerminating;

/*!
 @brief Starts all core threads, causing them to idly wait for work.This
  overrides the default policy of starting core threads only when
  new tasks are executed.
 @return the number of threads started
 */
- (jint)prestartAllCoreThreads;

/*!
 @brief Starts a core thread, causing it to idly wait for work.This
  overrides the default policy of starting core threads only when
  new tasks are executed.
 This method will return <code>false</code>
  if all core threads have already been started.
 @return <code>true</code> if a thread was started
 */
- (jboolean)prestartCoreThread;

/*!
 @brief Tries to remove from the work queue all <code>Future</code>
  tasks that have been cancelled.This method can be useful as a
  storage reclamation operation, that has no other impact on
  functionality.
 Cancelled tasks are never executed, but may
  accumulate in work queues until worker threads can actively
  remove them. Invoking this method instead tries to remove them now.
  However, this method may fail to remove tasks in
  the presence of interference by other threads.
 */
- (void)purge;

/*!
 @brief Removes this task from the executor's internal queue if it is
  present, thus causing it not to be run if it has not already
  started.
 <p>This method may be useful as one part of a cancellation
  scheme.  It may fail to remove tasks that have been converted
  into other forms before being placed on the internal queue.
  For example, a task entered using <code>submit</code> might be
  converted into a form that maintains <code>Future</code> status.
  However, in such cases, method <code>purge</code> may be used to
  remove those Futures that have been cancelled.
 @param task the task to remove
 @return <code>true</code> if the task was removed
 */
- (jboolean)removeWithJavaLangRunnable:(id<JavaLangRunnable>)task;

/*!
 @brief Sets the core number of threads.This overrides any value set
  in the constructor.
 If the new value is smaller than the
  current value, excess existing threads will be terminated when
  they next become idle.  If larger, new threads will, if needed,
  be started to execute any queued tasks.
 @param corePoolSize the new core size
 @throw IllegalArgumentExceptionif <code>corePoolSize < 0</code>
 - seealso: #getCorePoolSize
 */
- (void)setCorePoolSizeWithInt:(jint)corePoolSize;

/*!
 @brief Sets the thread keep-alive time, which is the amount of time
  that threads may remain idle before being terminated.
 Threads that wait this amount of time without processing a
  task will be terminated if there are more than the core
  number of threads currently in the pool, or if this pool 
 core thread timeout.
  This overrides any value set in the constructor.
 @param time the time to wait.  A time value of zero will cause         excess threads to terminate immediately after executing tasks.
 @param unit the time unit of the <code>time</code>  argument
 @throw IllegalArgumentExceptionif <code>time</code> less than zero or
          if <code>time</code> is zero and <code>allowsCoreThreadTimeOut</code>
 - seealso: #getKeepAliveTime(TimeUnit)
 */
- (void)setKeepAliveTimeWithLong:(jlong)time
  withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit *)unit;

/*!
 @brief Sets the maximum allowed number of threads.This overrides any
  value set in the constructor.
 If the new value is smaller than
  the current value, excess existing threads will be
  terminated when they next become idle.
 @param maximumPoolSize the new maximum
 @throw IllegalArgumentExceptionif the new maximum is
          less than or equal to zero, or
          less than the pool size
 - seealso: #getMaximumPoolSize
 */
- (void)setMaximumPoolSizeWithInt:(jint)maximumPoolSize;

/*!
 @brief Sets a new handler for unexecutable tasks.
 @param handler the new handler
 @throw NullPointerExceptionif handler is null
 - seealso: #getRejectedExecutionHandler
 */
- (void)setRejectedExecutionHandlerWithJavaUtilConcurrentRejectedExecutionHandler:(id<JavaUtilConcurrentRejectedExecutionHandler>)handler;

/*!
 @brief Sets the thread factory used to create new threads.
 @param threadFactory the new thread factory
 @throw NullPointerExceptionif threadFactory is null
 - seealso: #getThreadFactory
 */
- (void)setThreadFactoryWithJavaUtilConcurrentThreadFactory:(id<JavaUtilConcurrentThreadFactory>)threadFactory;

/*!
 @brief Initiates an orderly shutdown in which previously submitted
  tasks are executed, but no new tasks will be accepted.
 Invocation has no additional effect if already shut down. 
 <p>This method does not wait for previously submitted tasks to
  complete execution.  Use <code>awaitTermination</code>
  to do that.
 */
- (void)shutdown;

/*!
 @brief Attempts to stop all actively executing tasks, halts the
  processing of waiting tasks, and returns a list of the tasks
  that were awaiting execution.These tasks are drained (removed)
  from the task queue upon return from this method.
 <p>This method does not wait for actively executing tasks to
  terminate.  Use <code>awaitTermination</code> to
  do that. 
 <p>There are no guarantees beyond best-effort attempts to stop
  processing actively executing tasks.  This implementation
  interrupts tasks via <code>Thread.interrupt</code>; any task that
  fails to respond to interrupts may never terminate.
 */
- (id<JavaUtilList>)shutdownNow;

/*!
 @brief Returns a string identifying this pool, as well as its state,
  including indications of run state and estimated worker and
  task counts.
 @return a string identifying this pool, as well as its state
 */
- (NSString *)description;

#pragma mark Protected

/*!
 @brief Method invoked upon completion of execution of the given Runnable.
 This method is invoked by the thread that executed the task. If
  non-null, the Throwable is the uncaught <code>RuntimeException</code>
  or <code>Error</code> that caused execution to terminate abruptly. 
 <p>This implementation does nothing, but may be customized in
  subclasses. Note: To properly nest multiple overridings, subclasses
  should generally invoke <code>super.afterExecute</code> at the
  beginning of this method. 
 <p><b>Note:</b> When actions are enclosed in tasks (such as 
 <code>FutureTask</code>) either explicitly or via methods such as 
 <code>submit</code>, these task objects catch and maintain
  computational exceptions, and so they do not cause abrupt
  termination, and the internal exceptions are <em>not</em>
  passed to this method. If you would like to trap both kinds of
  failures in this method, you can further probe for such cases,
  as in this sample subclass that prints either the direct cause
  or the underlying exception if a task has been aborted: 
 @code
  class ExtendedExecutor extends ThreadPoolExecutor {
    // ...
    protected void afterExecute(Runnable r, Throwable t) {
      super.afterExecute(r, t);
      if (t == null
          && r instanceof Future<?>
          && ((Future<?>)r).isDone()) {
        try {
          Object result = ((Future<?>) r).get();
        } catch (CancellationException ce) {
          t = ce;
        } catch (ExecutionException ee) {
          t = ee.getCause();
        } catch (InterruptedException ie) {
          // ignore/reset
          Thread.currentThread().interrupt();
        }      }
      if (t != null)
        System.out.println(t);
    }  }
 
@endcode
 @param r the runnable that has completed
 @param t the exception that caused termination, or null if  execution completed normally
 */
- (void)afterExecuteWithJavaLangRunnable:(id<JavaLangRunnable>)r
                   withJavaLangThrowable:(JavaLangThrowable *)t;

/*!
 @brief Method invoked prior to executing the given Runnable in the
  given thread.This method is invoked by thread <code>t</code> that
  will execute task <code>r</code>, and may be used to re-initialize
  ThreadLocals, or to perform logging.
 <p>This implementation does nothing, but may be customized in
  subclasses. Note: To properly nest multiple overridings, subclasses
  should generally invoke <code>super.beforeExecute</code> at the end of
  this method.
 @param t the thread that will run task <code>r</code>
 @param r the task that will be executed
 */
- (void)beforeExecuteWithJavaLangThread:(JavaLangThread *)t
                   withJavaLangRunnable:(id<JavaLangRunnable>)r;

/*!
 @brief Invokes <code>shutdown</code> when this executor is no longer
  referenced and it has no threads.
 */
- (void)java_finalize;

/*!
 @brief Method invoked when the Executor has terminated.Default
  implementation does nothing.
 Note: To properly nest multiple
  overridings, subclasses should generally invoke 
 <code>super.terminated</code> within this method.
 */
- (void)terminated;

#pragma mark Package-Private

/*!
 @brief Same as prestartCoreThread except arranges that at least one
  thread is started even if corePoolSize is 0.
 */
- (void)ensurePrestart;

/*!
 @brief State check needed by ScheduledThreadPoolExecutor to
  enable running tasks during shutdown.
 @param shutdownOK true if should return true if SHUTDOWN
 */
- (jboolean)isRunningOrShutdownWithBoolean:(jboolean)shutdownOK;

/*!
 @brief Performs any further cleanup following run state transition on
  invocation of shutdown.A no-op here, but used by
  ScheduledThreadPoolExecutor to cancel delayed tasks.
 */
- (void)onShutdown;

/*!
 @brief Invokes the rejected execution handler for the given command.
 Package-protected for use by ScheduledThreadPoolExecutor.
 */
- (void)rejectWithJavaLangRunnable:(id<JavaLangRunnable>)command;

/*!
 @brief Main worker run loop.Repeatedly gets tasks from queue and
  executes them, while coping with a number of issues:
  1.
 We may start out with an initial task, in which case we
  don't need to get the first one. Otherwise, as long as pool is
  running, we get tasks from getTask. If it returns null then the
  worker exits due to changed pool state or configuration
  parameters.  Other exits result from exception throws in
  external code, in which case completedAbruptly holds, which
  usually leads processWorkerExit to replace this thread.
  2. Before running any task, the lock is acquired to prevent
  other pool interrupts while the task is executing, and then we
  ensure that unless pool is stopping, this thread does not have
  its interrupt set.
  3. Each task run is preceded by a call to beforeExecute, which
  might throw an exception, in which case we cause thread to die
  (breaking loop with completedAbruptly true) without processing
  the task.
  4. Assuming beforeExecute completes normally, we run the task,
  gathering any of its thrown exceptions to send to afterExecute.
  We separately handle RuntimeException, Error (both of which the
  specs guarantee that we trap) and arbitrary Throwables.
  Because we cannot rethrow Throwables within Runnable.run, we
  wrap them within Errors on the way out (to the thread's
  UncaughtExceptionHandler).  Any thrown exception also
  conservatively causes thread to die.
  5. After task.run completes, we call afterExecute, which may
  also throw an exception, which will also cause thread to
  die. According to JLS Sec 14.20, this exception is the one that
  will be in effect even if task.run throws.
  The net effect of the exception mechanics is that afterExecute
  and the thread's UncaughtExceptionHandler have as accurate
  information as we can provide about any problems encountered by
  user code.
 @param w the worker
 */
- (void)runWorkerWithJavaUtilConcurrentThreadPoolExecutor_Worker:(JavaUtilConcurrentThreadPoolExecutor_Worker *)w;

/*!
 @brief Transitions to TERMINATED state if either (SHUTDOWN and pool
  and queue empty) or (STOP and pool empty).If otherwise
  eligible to terminate but workerCount is nonzero, interrupts an
  idle worker to ensure that shutdown signals propagate.
 This
  method must be called following any action that might make
  termination possible -- reducing worker count or removing tasks
  from the queue during shutdown. The method is non-private to
  allow access from ScheduledThreadPoolExecutor.
 */
- (void)tryTerminate;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)init NS_UNAVAILABLE;

@end

J2OBJC_STATIC_INIT(JavaUtilConcurrentThreadPoolExecutor)

FOUNDATION_EXPORT void JavaUtilConcurrentThreadPoolExecutor_initWithInt_withInt_withLong_withJavaUtilConcurrentTimeUnit_withJavaUtilConcurrentBlockingQueue_(JavaUtilConcurrentThreadPoolExecutor *self, jint corePoolSize, jint maximumPoolSize, jlong keepAliveTime, JavaUtilConcurrentTimeUnit *unit, id<JavaUtilConcurrentBlockingQueue> workQueue);

FOUNDATION_EXPORT JavaUtilConcurrentThreadPoolExecutor *new_JavaUtilConcurrentThreadPoolExecutor_initWithInt_withInt_withLong_withJavaUtilConcurrentTimeUnit_withJavaUtilConcurrentBlockingQueue_(jint corePoolSize, jint maximumPoolSize, jlong keepAliveTime, JavaUtilConcurrentTimeUnit *unit, id<JavaUtilConcurrentBlockingQueue> workQueue) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilConcurrentThreadPoolExecutor *create_JavaUtilConcurrentThreadPoolExecutor_initWithInt_withInt_withLong_withJavaUtilConcurrentTimeUnit_withJavaUtilConcurrentBlockingQueue_(jint corePoolSize, jint maximumPoolSize, jlong keepAliveTime, JavaUtilConcurrentTimeUnit *unit, id<JavaUtilConcurrentBlockingQueue> workQueue);

FOUNDATION_EXPORT void JavaUtilConcurrentThreadPoolExecutor_initWithInt_withInt_withLong_withJavaUtilConcurrentTimeUnit_withJavaUtilConcurrentBlockingQueue_withJavaUtilConcurrentThreadFactory_(JavaUtilConcurrentThreadPoolExecutor *self, jint corePoolSize, jint maximumPoolSize, jlong keepAliveTime, JavaUtilConcurrentTimeUnit *unit, id<JavaUtilConcurrentBlockingQueue> workQueue, id<JavaUtilConcurrentThreadFactory> threadFactory);

FOUNDATION_EXPORT JavaUtilConcurrentThreadPoolExecutor *new_JavaUtilConcurrentThreadPoolExecutor_initWithInt_withInt_withLong_withJavaUtilConcurrentTimeUnit_withJavaUtilConcurrentBlockingQueue_withJavaUtilConcurrentThreadFactory_(jint corePoolSize, jint maximumPoolSize, jlong keepAliveTime, JavaUtilConcurrentTimeUnit *unit, id<JavaUtilConcurrentBlockingQueue> workQueue, id<JavaUtilConcurrentThreadFactory> threadFactory) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilConcurrentThreadPoolExecutor *create_JavaUtilConcurrentThreadPoolExecutor_initWithInt_withInt_withLong_withJavaUtilConcurrentTimeUnit_withJavaUtilConcurrentBlockingQueue_withJavaUtilConcurrentThreadFactory_(jint corePoolSize, jint maximumPoolSize, jlong keepAliveTime, JavaUtilConcurrentTimeUnit *unit, id<JavaUtilConcurrentBlockingQueue> workQueue, id<JavaUtilConcurrentThreadFactory> threadFactory);

FOUNDATION_EXPORT void JavaUtilConcurrentThreadPoolExecutor_initWithInt_withInt_withLong_withJavaUtilConcurrentTimeUnit_withJavaUtilConcurrentBlockingQueue_withJavaUtilConcurrentRejectedExecutionHandler_(JavaUtilConcurrentThreadPoolExecutor *self, jint corePoolSize, jint maximumPoolSize, jlong keepAliveTime, JavaUtilConcurrentTimeUnit *unit, id<JavaUtilConcurrentBlockingQueue> workQueue, id<JavaUtilConcurrentRejectedExecutionHandler> handler);

FOUNDATION_EXPORT JavaUtilConcurrentThreadPoolExecutor *new_JavaUtilConcurrentThreadPoolExecutor_initWithInt_withInt_withLong_withJavaUtilConcurrentTimeUnit_withJavaUtilConcurrentBlockingQueue_withJavaUtilConcurrentRejectedExecutionHandler_(jint corePoolSize, jint maximumPoolSize, jlong keepAliveTime, JavaUtilConcurrentTimeUnit *unit, id<JavaUtilConcurrentBlockingQueue> workQueue, id<JavaUtilConcurrentRejectedExecutionHandler> handler) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilConcurrentThreadPoolExecutor *create_JavaUtilConcurrentThreadPoolExecutor_initWithInt_withInt_withLong_withJavaUtilConcurrentTimeUnit_withJavaUtilConcurrentBlockingQueue_withJavaUtilConcurrentRejectedExecutionHandler_(jint corePoolSize, jint maximumPoolSize, jlong keepAliveTime, JavaUtilConcurrentTimeUnit *unit, id<JavaUtilConcurrentBlockingQueue> workQueue, id<JavaUtilConcurrentRejectedExecutionHandler> handler);

FOUNDATION_EXPORT void JavaUtilConcurrentThreadPoolExecutor_initWithInt_withInt_withLong_withJavaUtilConcurrentTimeUnit_withJavaUtilConcurrentBlockingQueue_withJavaUtilConcurrentThreadFactory_withJavaUtilConcurrentRejectedExecutionHandler_(JavaUtilConcurrentThreadPoolExecutor *self, jint corePoolSize, jint maximumPoolSize, jlong keepAliveTime, JavaUtilConcurrentTimeUnit *unit, id<JavaUtilConcurrentBlockingQueue> workQueue, id<JavaUtilConcurrentThreadFactory> threadFactory, id<JavaUtilConcurrentRejectedExecutionHandler> handler);

FOUNDATION_EXPORT JavaUtilConcurrentThreadPoolExecutor *new_JavaUtilConcurrentThreadPoolExecutor_initWithInt_withInt_withLong_withJavaUtilConcurrentTimeUnit_withJavaUtilConcurrentBlockingQueue_withJavaUtilConcurrentThreadFactory_withJavaUtilConcurrentRejectedExecutionHandler_(jint corePoolSize, jint maximumPoolSize, jlong keepAliveTime, JavaUtilConcurrentTimeUnit *unit, id<JavaUtilConcurrentBlockingQueue> workQueue, id<JavaUtilConcurrentThreadFactory> threadFactory, id<JavaUtilConcurrentRejectedExecutionHandler> handler) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilConcurrentThreadPoolExecutor *create_JavaUtilConcurrentThreadPoolExecutor_initWithInt_withInt_withLong_withJavaUtilConcurrentTimeUnit_withJavaUtilConcurrentBlockingQueue_withJavaUtilConcurrentThreadFactory_withJavaUtilConcurrentRejectedExecutionHandler_(jint corePoolSize, jint maximumPoolSize, jlong keepAliveTime, JavaUtilConcurrentTimeUnit *unit, id<JavaUtilConcurrentBlockingQueue> workQueue, id<JavaUtilConcurrentThreadFactory> threadFactory, id<JavaUtilConcurrentRejectedExecutionHandler> handler);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilConcurrentThreadPoolExecutor)

#endif

#if !defined (JavaUtilConcurrentThreadPoolExecutor_CallerRunsPolicy_) && (INCLUDE_ALL_JavaUtilConcurrentThreadPoolExecutor || defined(INCLUDE_JavaUtilConcurrentThreadPoolExecutor_CallerRunsPolicy))
#define JavaUtilConcurrentThreadPoolExecutor_CallerRunsPolicy_

#define RESTRICT_JavaUtilConcurrentRejectedExecutionHandler 1
#define INCLUDE_JavaUtilConcurrentRejectedExecutionHandler 1
#include "java/util/concurrent/RejectedExecutionHandler.h"

@class JavaUtilConcurrentThreadPoolExecutor;
@protocol JavaLangRunnable;

/*!
 @brief A handler for rejected tasks that runs the rejected task
  directly in the calling thread of the <code>execute</code> method,
  unless the executor has been shut down, in which case the task
  is discarded.
 */
@interface JavaUtilConcurrentThreadPoolExecutor_CallerRunsPolicy : NSObject < JavaUtilConcurrentRejectedExecutionHandler >

#pragma mark Public

/*!
 @brief Creates a <code>CallerRunsPolicy</code>.
 */
- (instancetype __nonnull)init;

/*!
 @brief Executes task r in the caller's thread, unless the executor
  has been shut down, in which case the task is discarded.
 @param r the runnable task requested to be executed
 @param e the executor attempting to execute this task
 */
- (void)rejectedExecutionWithJavaLangRunnable:(id<JavaLangRunnable>)r
     withJavaUtilConcurrentThreadPoolExecutor:(JavaUtilConcurrentThreadPoolExecutor *)e;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilConcurrentThreadPoolExecutor_CallerRunsPolicy)

FOUNDATION_EXPORT void JavaUtilConcurrentThreadPoolExecutor_CallerRunsPolicy_init(JavaUtilConcurrentThreadPoolExecutor_CallerRunsPolicy *self);

FOUNDATION_EXPORT JavaUtilConcurrentThreadPoolExecutor_CallerRunsPolicy *new_JavaUtilConcurrentThreadPoolExecutor_CallerRunsPolicy_init(void) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilConcurrentThreadPoolExecutor_CallerRunsPolicy *create_JavaUtilConcurrentThreadPoolExecutor_CallerRunsPolicy_init(void);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilConcurrentThreadPoolExecutor_CallerRunsPolicy)

#endif

#if !defined (JavaUtilConcurrentThreadPoolExecutor_AbortPolicy_) && (INCLUDE_ALL_JavaUtilConcurrentThreadPoolExecutor || defined(INCLUDE_JavaUtilConcurrentThreadPoolExecutor_AbortPolicy))
#define JavaUtilConcurrentThreadPoolExecutor_AbortPolicy_

#define RESTRICT_JavaUtilConcurrentRejectedExecutionHandler 1
#define INCLUDE_JavaUtilConcurrentRejectedExecutionHandler 1
#include "java/util/concurrent/RejectedExecutionHandler.h"

@class JavaUtilConcurrentThreadPoolExecutor;
@protocol JavaLangRunnable;

/*!
 @brief A handler for rejected tasks that throws a 
 <code>RejectedExecutionException</code>.
 */
@interface JavaUtilConcurrentThreadPoolExecutor_AbortPolicy : NSObject < JavaUtilConcurrentRejectedExecutionHandler >

#pragma mark Public

/*!
 @brief Creates an <code>AbortPolicy</code>.
 */
- (instancetype __nonnull)init;

/*!
 @brief Always throws RejectedExecutionException.
 @param r the runnable task requested to be executed
 @param e the executor attempting to execute this task
 @throw RejectedExecutionExceptionalways
 */
- (void)rejectedExecutionWithJavaLangRunnable:(id<JavaLangRunnable>)r
     withJavaUtilConcurrentThreadPoolExecutor:(JavaUtilConcurrentThreadPoolExecutor *)e;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilConcurrentThreadPoolExecutor_AbortPolicy)

FOUNDATION_EXPORT void JavaUtilConcurrentThreadPoolExecutor_AbortPolicy_init(JavaUtilConcurrentThreadPoolExecutor_AbortPolicy *self);

FOUNDATION_EXPORT JavaUtilConcurrentThreadPoolExecutor_AbortPolicy *new_JavaUtilConcurrentThreadPoolExecutor_AbortPolicy_init(void) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilConcurrentThreadPoolExecutor_AbortPolicy *create_JavaUtilConcurrentThreadPoolExecutor_AbortPolicy_init(void);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilConcurrentThreadPoolExecutor_AbortPolicy)

#endif

#if !defined (JavaUtilConcurrentThreadPoolExecutor_DiscardPolicy_) && (INCLUDE_ALL_JavaUtilConcurrentThreadPoolExecutor || defined(INCLUDE_JavaUtilConcurrentThreadPoolExecutor_DiscardPolicy))
#define JavaUtilConcurrentThreadPoolExecutor_DiscardPolicy_

#define RESTRICT_JavaUtilConcurrentRejectedExecutionHandler 1
#define INCLUDE_JavaUtilConcurrentRejectedExecutionHandler 1
#include "java/util/concurrent/RejectedExecutionHandler.h"

@class JavaUtilConcurrentThreadPoolExecutor;
@protocol JavaLangRunnable;

/*!
 @brief A handler for rejected tasks that silently discards the
  rejected task.
 */
@interface JavaUtilConcurrentThreadPoolExecutor_DiscardPolicy : NSObject < JavaUtilConcurrentRejectedExecutionHandler >

#pragma mark Public

/*!
 @brief Creates a <code>DiscardPolicy</code>.
 */
- (instancetype __nonnull)init;

/*!
 @brief Does nothing, which has the effect of discarding task r.
 @param r the runnable task requested to be executed
 @param e the executor attempting to execute this task
 */
- (void)rejectedExecutionWithJavaLangRunnable:(id<JavaLangRunnable>)r
     withJavaUtilConcurrentThreadPoolExecutor:(JavaUtilConcurrentThreadPoolExecutor *)e;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilConcurrentThreadPoolExecutor_DiscardPolicy)

FOUNDATION_EXPORT void JavaUtilConcurrentThreadPoolExecutor_DiscardPolicy_init(JavaUtilConcurrentThreadPoolExecutor_DiscardPolicy *self);

FOUNDATION_EXPORT JavaUtilConcurrentThreadPoolExecutor_DiscardPolicy *new_JavaUtilConcurrentThreadPoolExecutor_DiscardPolicy_init(void) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilConcurrentThreadPoolExecutor_DiscardPolicy *create_JavaUtilConcurrentThreadPoolExecutor_DiscardPolicy_init(void);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilConcurrentThreadPoolExecutor_DiscardPolicy)

#endif

#if !defined (JavaUtilConcurrentThreadPoolExecutor_DiscardOldestPolicy_) && (INCLUDE_ALL_JavaUtilConcurrentThreadPoolExecutor || defined(INCLUDE_JavaUtilConcurrentThreadPoolExecutor_DiscardOldestPolicy))
#define JavaUtilConcurrentThreadPoolExecutor_DiscardOldestPolicy_

#define RESTRICT_JavaUtilConcurrentRejectedExecutionHandler 1
#define INCLUDE_JavaUtilConcurrentRejectedExecutionHandler 1
#include "java/util/concurrent/RejectedExecutionHandler.h"

@class JavaUtilConcurrentThreadPoolExecutor;
@protocol JavaLangRunnable;

/*!
 @brief A handler for rejected tasks that discards the oldest unhandled
  request and then retries <code>execute</code>, unless the executor
  is shut down, in which case the task is discarded.
 */
@interface JavaUtilConcurrentThreadPoolExecutor_DiscardOldestPolicy : NSObject < JavaUtilConcurrentRejectedExecutionHandler >

#pragma mark Public

/*!
 @brief Creates a <code>DiscardOldestPolicy</code> for the given executor.
 */
- (instancetype __nonnull)init;

/*!
 @brief Obtains and ignores the next task that the executor
  would otherwise execute, if one is immediately available,
  and then retries execution of task r, unless the executor
  is shut down, in which case task r is instead discarded.
 @param r the runnable task requested to be executed
 @param e the executor attempting to execute this task
 */
- (void)rejectedExecutionWithJavaLangRunnable:(id<JavaLangRunnable>)r
     withJavaUtilConcurrentThreadPoolExecutor:(JavaUtilConcurrentThreadPoolExecutor *)e;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilConcurrentThreadPoolExecutor_DiscardOldestPolicy)

FOUNDATION_EXPORT void JavaUtilConcurrentThreadPoolExecutor_DiscardOldestPolicy_init(JavaUtilConcurrentThreadPoolExecutor_DiscardOldestPolicy *self);

FOUNDATION_EXPORT JavaUtilConcurrentThreadPoolExecutor_DiscardOldestPolicy *new_JavaUtilConcurrentThreadPoolExecutor_DiscardOldestPolicy_init(void) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilConcurrentThreadPoolExecutor_DiscardOldestPolicy *create_JavaUtilConcurrentThreadPoolExecutor_DiscardOldestPolicy_init(void);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilConcurrentThreadPoolExecutor_DiscardOldestPolicy)

#endif


#if __has_feature(nullability)
#pragma clang diagnostic pop
#endif

#pragma clang diagnostic pop
#pragma pop_macro("INCLUDE_ALL_JavaUtilConcurrentThreadPoolExecutor")
