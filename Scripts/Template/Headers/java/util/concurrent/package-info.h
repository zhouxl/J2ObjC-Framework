//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: android/platform/libcore/luni/src/main/java/java/util/concurrent/package-info.java
//

/*!
 @brief Utility classes commonly useful in concurrent programming.This
  package includes a few small standardized extensible frameworks, as
  well as some classes that provide useful functionality and are
  otherwise tedious or difficult to implement.
 Here are brief
  descriptions of the main components.  See also the 
 <code>java.util.concurrent.locks</code> and 
 <code>java.util.concurrent.atomic</code> packages. 
 <h2>Executors</h2>
  
 <b>Interfaces.</b>
  
 <code>java.util.concurrent.Executor</code> is a simple standardized
  interface for defining custom thread-like subsystems, including
  thread pools, asynchronous I/O, and lightweight task frameworks.
  Depending on which concrete Executor class is being used, tasks may
  execute in a newly created thread, an existing task-execution thread,
  or the thread calling <code>execute</code>
 , and may execute sequentially or concurrently. 
 <code>java.util.concurrent.ExecutorService</code> provides a more
  complete asynchronous task execution framework.  An
  ExecutorService manages queuing and scheduling of tasks,
  and allows controlled shutdown.
  The <code>java.util.concurrent.ScheduledExecutorService</code>
  subinterface and associated interfaces add support for
  delayed and periodic task execution.  ExecutorServices
  provide methods arranging asynchronous execution of any
  function expressed as <code>java.util.concurrent.Callable</code>,
  the result-bearing analog of <code>java.lang.Runnable</code>.
  A <code>java.util.concurrent.Future</code> returns the results of
  a function, allows determination of whether execution has
  completed, and provides a means to cancel execution.
  A <code>java.util.concurrent.RunnableFuture</code> is a <code>Future</code>
  that possesses a <code>run</code> method that upon execution,
  sets its results. 
 <p>
  
 <b>Implementations.</b>
  Classes <code>java.util.concurrent.ThreadPoolExecutor</code> and 
 <code>java.util.concurrent.ScheduledThreadPoolExecutor</code>
  provide tunable, flexible thread pools.
  The <code>java.util.concurrent.Executors</code> class provides
  factory methods for the most common kinds and configurations
  of Executors, as well as a few utility methods for using
  them.  Other utilities based on <code>Executors</code> include the
  concrete class <code>java.util.concurrent.FutureTask</code>
  providing a common extensible implementation of Futures, and 
 <code>java.util.concurrent.ExecutorCompletionService</code>, that
  assists in coordinating the processing of groups of
  asynchronous tasks. 
 <p>Class <code>java.util.concurrent.ForkJoinPool</code> provides an
  Executor primarily designed for processing instances of <code>java.util.concurrent.ForkJoinTask</code>
  and its subclasses.  These
  classes employ a work-stealing scheduler that attains high
  throughput for tasks conforming to restrictions that often hold in
  computation-intensive parallel processing. 
 <h2>Queues</h2>
  The <code>java.util.concurrent.ConcurrentLinkedQueue</code> class
  supplies an efficient scalable thread-safe non-blocking FIFO queue.
  The <code>java.util.concurrent.ConcurrentLinkedDeque</code> class is
  similar, but additionally supports the <code>java.util.Deque</code>
  interface. 
 <p>Five implementations in <code>java.util.concurrent</code> support
  the extended <code>java.util.concurrent.BlockingQueue</code>
  interface, that defines blocking versions of put and take: 
 <code>java.util.concurrent.LinkedBlockingQueue</code>,
  <code>java.util.concurrent.ArrayBlockingQueue</code>,
  <code>java.util.concurrent.SynchronousQueue</code>,
  <code>java.util.concurrent.PriorityBlockingQueue</code>, and 
 <code>java.util.concurrent.DelayQueue</code>.
  The different classes cover the most common usage contexts
  for producer-consumer, messaging, parallel tasking, and
  related concurrent designs. 
 <p>Extended interface <code>java.util.concurrent.TransferQueue</code>,
  and implementation <code>java.util.concurrent.LinkedTransferQueue</code>
  introduce a synchronous <code>transfer</code> method (along with related
  features) in which a producer may optionally block awaiting its
  consumer. 
 <p>The <code>java.util.concurrent.BlockingDeque</code> interface
  extends <code>BlockingQueue</code> to support both FIFO and LIFO
  (stack-based) operations.
  Class <code>java.util.concurrent.LinkedBlockingDeque</code>
  provides an implementation. 
 <h2>Timing</h2>
  The <code>java.util.concurrent.TimeUnit</code> class provides
  multiple granularities (including nanoseconds) for
  specifying and controlling time-out based operations.  Most
  classes in the package contain operations based on time-outs
  in addition to indefinite waits.  In all cases that
  time-outs are used, the time-out specifies the minimum time
  that the method should wait before indicating that it
  timed-out.  Implementations make a &quot;best effort&quot;
  to detect time-outs as soon as possible after they occur.
  However, an indefinite amount of time may elapse between a
  time-out being detected and a thread actually executing
  again after that time-out.  All methods that accept timeout
  parameters treat values less than or equal to zero to mean
  not to wait at all.  To wait "forever", you can use a value
  of <code>Long.MAX_VALUE</code>.
  
 <h2>Synchronizers</h2>
  Five classes aid common special-purpose synchronization idioms. 
 <ul>
  
 <li><code>java.util.concurrent.Semaphore</code> is a classic concurrency tool. 
 <li><code>java.util.concurrent.CountDownLatch</code> is a very simple yet
  very common utility for blocking until a given number of signals,
  events, or conditions hold. 
 <li>A <code>java.util.concurrent.CyclicBarrier</code> is a resettable
  multiway synchronization point useful in some styles of parallel
  programming. 
 <li>A <code>java.util.concurrent.Phaser</code> provides
  a more flexible form of barrier that may be used to control phased
  computation among multiple threads. 
 <li>An <code>java.util.concurrent.Exchanger</code> allows two threads to
  exchange objects at a rendezvous point, and is useful in several
  pipeline designs. 
 </ul>
  
 <h2>Concurrent Collections</h2>
  Besides Queues, this package supplies Collection implementations
  designed for use in multithreaded contexts: 
 <code>java.util.concurrent.ConcurrentHashMap</code>,
  <code>java.util.concurrent.ConcurrentSkipListMap</code>,
  <code>java.util.concurrent.ConcurrentSkipListSet</code>,
  <code>java.util.concurrent.CopyOnWriteArrayList</code>, and 
 <code>java.util.concurrent.CopyOnWriteArraySet</code>.
  When many threads are expected to access a given collection, a 
 <code>ConcurrentHashMap</code> is normally preferable to a synchronized 
 <code>HashMap</code>, and a <code>ConcurrentSkipListMap</code> is normally
  preferable to a synchronized <code>TreeMap</code>.
  A <code>CopyOnWriteArrayList</code> is preferable to a synchronized 
 <code>ArrayList</code> when the expected number of reads and traversals
  greatly outnumber the number of updates to a list. 
 <p>The "Concurrent" prefix used with some classes in this package
  is a shorthand indicating several differences from similar
  "synchronized" classes.  For example <code>java.util.Hashtable</code> and 
 <code>Collections.synchronizedMap(new HashMap())</code> are
  synchronized.  But <code>java.util.concurrent.ConcurrentHashMap</code>
  is "concurrent".  A
  concurrent collection is thread-safe, but not governed by a
  single exclusion lock.  In the particular case of
  ConcurrentHashMap, it safely permits any number of
  concurrent reads as well as a tunable number of concurrent
  writes.  "Synchronized" classes can be useful when you need
  to prevent all access to a collection via a single lock, at
  the expense of poorer scalability.  In other cases in which
  multiple threads are expected to access a common collection,
  "concurrent" versions are normally preferable.  And
  unsynchronized collections are preferable when either
  collections are unshared, or are accessible only when
  holding other locks. 
 <p id="Weakly">Most concurrent Collection implementations
  (including most Queues) also differ from the usual <code>java.util</code>
  conventions in that their Iterators
  and Spliterators provide 
 <em>weakly consistent</em> rather than fast-fail traversal: 
 <ul>
  <li>they may proceed concurrently with other operations 
 <li>they will never throw <code>ConcurrentModificationException</code>
  <li>they are guaranteed to traverse elements as they existed upon
  construction exactly once, and may (but are not guaranteed to)
  reflect any modifications subsequent to construction. 
 </ul>
  
 <h2 id="MemoryVisibility">Memory Consistency Properties</h2>
  
 <a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-17.html#jls-17.4.5">
  Chapter 17 of 
 <cite>The Java&trade; Language Specification</cite></a> defines the 
 <i>happens-before</i> relation on memory operations such as reads and
  writes of shared variables.  The results of a write by one thread are
  guaranteed to be visible to a read by another thread only if the write
  operation <i>happens-before</i> the read operation.  The 
 <code>synchronized</code> and <code>volatile</code> constructs, as well as the 
 <code>Thread.start()</code> and <code>Thread.join()</code> methods, can form 
 <i>happens-before</i> relationships.  In particular: 
 <ul>
    <li>Each action in a thread <i>happens-before</i> every action in that
    thread that comes later in the program's order.   
 <li>An unlock (<code>synchronized</code> block or method exit) of a
    monitor <i>happens-before</i> every subsequent lock (<code>synchronized</code>
    block or method entry) of that same monitor.  And because
    the <i>happens-before</i> relation is transitive, all actions
    of a thread prior to unlocking <i>happen-before</i> all actions
    subsequent to any thread locking that monitor.   
 <li>A write to a <code>volatile</code> field <i>happens-before</i> every
    subsequent read of that same field.  Writes and reads of   
 <code>volatile</code> fields have similar memory consistency effects
    as entering and exiting monitors, but do <em>not</em> entail
    mutual exclusion locking.   
 <li>A call to <code>start</code> on a thread <i>happens-before</i> any
    action in the started thread.   
 <li>All actions in a thread <i>happen-before</i> any other thread
    successfully returns from a <code>join</code> on that thread. 
 </ul>
  The methods of all classes in <code>java.util.concurrent</code> and its
  subpackages extend these guarantees to higher-level
  synchronization.  In particular: 
 <ul>
    <li>Actions in a thread prior to placing an object into any concurrent
    collection <i>happen-before</i> actions subsequent to the access or
    removal of that element from the collection in another thread.   
 <li>Actions in a thread prior to the submission of a <code>Runnable</code>
    to an <code>Executor</code> <i>happen-before</i> its execution begins.
    Similarly for <code>Callables</code> submitted to an <code>ExecutorService</code>.
    <li>Actions taken by the asynchronous computation represented by a
    <code>Future</code> <i>happen-before</i> actions subsequent to the
    retrieval of the result via <code>Future.get()</code> in another thread.
    <li>Actions prior to "releasing" synchronizer methods such as
    <code>Lock.unlock</code>, <code>Semaphore.release</code>, and
    <code>CountDownLatch.countDown</code> <i>happen-before</i> actions
    subsequent to a successful "acquiring" method such as   
 <code>Lock.lock</code>, <code>Semaphore.acquire</code>,
    <code>Condition.await</code>, and <code>CountDownLatch.await</code> on the
    same synchronizer object in another thread.   
 <li>For each pair of threads that successfully exchange objects via
    an <code>Exchanger</code>, actions prior to the <code>exchange()</code>
    in each thread <i>happen-before</i> those subsequent to the
    corresponding <code>exchange()</code> in another thread.
    <li>Actions prior to calling <code>CyclicBarrier.await</code> and
    <code>Phaser.awaitAdvance</code> (as well as its variants)
    <i>happen-before</i> actions performed by the barrier action, and
    actions performed by the barrier action <i>happen-before</i> actions
    subsequent to a successful return from the corresponding <code>await</code>
    in other threads. 
 </ul>
 @since 1.5
 */
#include "../../../J2ObjC_header.h"

#pragma push_macro("INCLUDE_ALL_JavaUtilConcurrentPackage_info")
#ifdef RESTRICT_JavaUtilConcurrentPackage_info
#define INCLUDE_ALL_JavaUtilConcurrentPackage_info 0
#else
#define INCLUDE_ALL_JavaUtilConcurrentPackage_info 1
#endif
#undef RESTRICT_JavaUtilConcurrentPackage_info

#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"

#if __has_feature(nullability)
#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wnullability"
#pragma GCC diagnostic ignored "-Wnullability-completeness"
#endif


#if __has_feature(nullability)
#pragma clang diagnostic pop
#endif

#pragma clang diagnostic pop
#pragma pop_macro("INCLUDE_ALL_JavaUtilConcurrentPackage_info")
